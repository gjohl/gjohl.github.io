<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Gurpreet Johl">
<meta name="dcterms.date" content="2025-01-27">
<meta name="description" content="Part 1 of 1: No Sequel">

<title>Gurpreet Johl - SQL</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Gurpreet Johl</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../blog.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/gjohl"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/gurpreetjohl"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/gurpreetjohl"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">SQL</h1>
                  <div>
        <div class="description">
          Part 1 of 1: No Sequel
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">InterviewPrep</div>
                <div class="quarto-category">Software</div>
                <div class="quarto-category">DataEngineering</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Gurpreet Johl </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 27, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sql-overview" id="toc-sql-overview" class="nav-link active" data-scroll-target="#sql-overview">1. SQL Overview</a>
  <ul class="collapse">
  <li><a href="#sql-and-rdbms" id="toc-sql-and-rdbms" class="nav-link" data-scroll-target="#sql-and-rdbms">1.1. SQL and RDBMS</a></li>
  <li><a href="#sql-flavours" id="toc-sql-flavours" class="nav-link" data-scroll-target="#sql-flavours">1.2. SQL Flavours</a></li>
  <li><a href="#postgresql" id="toc-postgresql" class="nav-link" data-scroll-target="#postgresql">1.3. PostgreSQL</a></li>
  </ul></li>
  <li><a href="#basic-sql-commands" id="toc-basic-sql-commands" class="nav-link" data-scroll-target="#basic-sql-commands">2. Basic SQL Commands</a>
  <ul class="collapse">
  <li><a href="#select" id="toc-select" class="nav-link" data-scroll-target="#select">2.1. SELECT</a></li>
  <li><a href="#where" id="toc-where" class="nav-link" data-scroll-target="#where">2.2. WHERE</a></li>
  <li><a href="#combining-conditions" id="toc-combining-conditions" class="nav-link" data-scroll-target="#combining-conditions">2.3. Combining Conditions</a></li>
  <li><a href="#between" id="toc-between" class="nav-link" data-scroll-target="#between">2.4. BETWEEN</a></li>
  <li><a href="#in" id="toc-in" class="nav-link" data-scroll-target="#in">2.5. IN</a></li>
  <li><a href="#like" id="toc-like" class="nav-link" data-scroll-target="#like">2.6. LIKE</a></li>
  <li><a href="#order-by" id="toc-order-by" class="nav-link" data-scroll-target="#order-by">2.7. ORDER BY</a></li>
  </ul></li>
  <li><a href="#intermediate-sql-commands" id="toc-intermediate-sql-commands" class="nav-link" data-scroll-target="#intermediate-sql-commands">3. Intermediate SQL Commands</a>
  <ul class="collapse">
  <li><a href="#aggregate-functions" id="toc-aggregate-functions" class="nav-link" data-scroll-target="#aggregate-functions">3.1. Aggregate Functions</a></li>
  <li><a href="#group-by" id="toc-group-by" class="nav-link" data-scroll-target="#group-by">3.2. GROUP BY</a></li>
  <li><a href="#having" id="toc-having" class="nav-link" data-scroll-target="#having">3.3. HAVING</a></li>
  <li><a href="#distinct" id="toc-distinct" class="nav-link" data-scroll-target="#distinct">3.4. DISTINCT</a></li>
  <li><a href="#arithmetic" id="toc-arithmetic" class="nav-link" data-scroll-target="#arithmetic">3.5. Arithmetic</a></li>
  <li><a href="#mathematical-functions" id="toc-mathematical-functions" class="nav-link" data-scroll-target="#mathematical-functions">3.6. Mathematical Functions</a></li>
  <li><a href="#division" id="toc-division" class="nav-link" data-scroll-target="#division">3.7. Division</a></li>
  <li><a href="#nulls" id="toc-nulls" class="nav-link" data-scroll-target="#nulls">3.8. Nulls</a></li>
  <li><a href="#case" id="toc-case" class="nav-link" data-scroll-target="#case">3.9. CASE</a></li>
  <li><a href="#join" id="toc-join" class="nav-link" data-scroll-target="#join">3.10. JOIN</a></li>
  <li><a href="#datetimes" id="toc-datetimes" class="nav-link" data-scroll-target="#datetimes">3.11. Datetimes</a></li>
  </ul></li>
  <li><a href="#advanced-sql" id="toc-advanced-sql" class="nav-link" data-scroll-target="#advanced-sql">4. Advanced SQL</a>
  <ul class="collapse">
  <li><a href="#cte-vs-subquery" id="toc-cte-vs-subquery" class="nav-link" data-scroll-target="#cte-vs-subquery">4.1. CTE vs Subquery</a>
  <ul class="collapse">
  <li><a href="#cte" id="toc-cte" class="nav-link" data-scroll-target="#cte">4.1.1. CTE</a></li>
  <li><a href="#subquery" id="toc-subquery" class="nav-link" data-scroll-target="#subquery">4.1.2. Subquery</a></li>
  </ul></li>
  <li><a href="#window" id="toc-window" class="nav-link" data-scroll-target="#window">4.2. WINDOW</a></li>
  <li><a href="#ranking" id="toc-ranking" class="nav-link" data-scroll-target="#ranking">4.3. Ranking</a></li>
  <li><a href="#leadlag" id="toc-leadlag" class="nav-link" data-scroll-target="#leadlag">4.4. Lead/Lag</a></li>
  <li><a href="#self-joins" id="toc-self-joins" class="nav-link" data-scroll-target="#self-joins">4.5. Self Joins</a></li>
  <li><a href="#set-operations---union-intersect-except" id="toc-set-operations---union-intersect-except" class="nav-link" data-scroll-target="#set-operations---union-intersect-except">4.6. Set operations - UNION, INTERSECT, EXCEPT</a></li>
  <li><a href="#sql-code-best-practices" id="toc-sql-code-best-practices" class="nav-link" data-scroll-target="#sql-code-best-practices">4.7. SQL Code Best Practices</a></li>
  <li><a href="#execution-order" id="toc-execution-order" class="nav-link" data-scroll-target="#execution-order">4.8. Execution Order</a></li>
  <li><a href="#string-functions" id="toc-string-functions" class="nav-link" data-scroll-target="#string-functions">4.9. String Functions</a></li>
  </ul></li>
  <li><a href="#creating-and-modifying-data" id="toc-creating-and-modifying-data" class="nav-link" data-scroll-target="#creating-and-modifying-data">5. Creating and Modifying Data</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="sql-overview" class="level1">
<h1>1. SQL Overview</h1>
<section id="sql-and-rdbms" class="level2">
<h2 class="anchored" data-anchor-id="sql-and-rdbms">1.1. SQL and RDBMS</h2>
<p>Structured Query Language (SQL) is used to manage and query data stored in a <strong>Relational Database Management System (RDMBS)</strong>. Essentially, put data in tables and get it out again.</p>
<p>An RDMBS organises data into tables with defined schemas (column names and data types).</p>
<p>SQL is a <em>declarative</em> language. You specify what you want to happen, not how to achieve it. The SQL query engine optimises how the query run internally, e.g.&nbsp;what order to execute commands, what indexes to use.</p>
</section>
<section id="sql-flavours" class="level2">
<h2 class="anchored" data-anchor-id="sql-flavours">1.2. SQL Flavours</h2>
<p>There are different “flavours” of SQL. For example, MySQL, PostegreSQL, SQLite, SQL Server. These are often, incorrectly, used interchangeably with SQL. SQL is a general, high-level language for querying RDMBSes.</p>
<p>The “flavours” are each a specific RDBMS which you query with the corresponding language. Postgres is an RDBMS which you can query by writing PostgreSQL. MySQL is and RDBMS which you can query by writing MySQL. Etc. In practice, the difference is pretty minimal. If you can use one, you’ll learn the others pretty quickly.</p>
</section>
<section id="postgresql" class="level2">
<h2 class="anchored" data-anchor-id="postgresql">1.3. PostgreSQL</h2>
<p>We use PostgreSQL and its associated Postgres RDBMS.</p>
<p>Some of the advantages of PostgreSQL:</p>
<ul>
<li><strong>Popularity</strong>: One of the most popular behind MySQL</li>
<li><strong>Open Source</strong>: BSD-style license is not too restrictive</li>
<li><strong>Extensible</strong>: Postgres has extensions like PostGIS for geospatial data, etc</li>
<li><strong>ANSI Compliant</strong>: American National Standards Institute (ANSI) define standards and PostgreSQL mostly conforms to these. One of the least quirky flavours of SQL.</li>
</ul>
</section>
</section>
<section id="basic-sql-commands" class="level1">
<h1>2. Basic SQL Commands</h1>
<section id="select" class="level2">
<h2 class="anchored" data-anchor-id="select">2.1. SELECT</h2>
<p>Use <code>SELECT</code> to read specific columns (or all with <code>*</code>) from a given table.</p>
<pre class="postgresql"><code>SELECT column1, column2
FROM table_name;</code></pre>
<p>We can optional use <code>LIMIT</code> to return a set number of rows. This can be helpful if we’re querying a massive table that might be a huge query.</p>
<pre class="postgresql"><code>SELECT *
FROM table_name
LIMIT 10</code></pre>
<p>We can use the <code>AS</code> keyword to alias a column name.</p>
<pre class="postgresql"><code>SELECT column1, column2 AS skibidi  -- using a stupid alias
FROM table_name;</code></pre>
<p>We can also add comments with <code>--</code> as above.</p>
</section>
<section id="where" class="level2">
<h2 class="anchored" data-anchor-id="where">2.2. WHERE</h2>
<p>Use <code>WHERE</code> to filter the result on a specific condition. Conditions can be: <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></p>
<pre class="postgresql"><code>SELECT column1, column2
FROM table_name
WHERE condition;</code></pre>
</section>
<section id="combining-conditions" class="level2">
<h2 class="anchored" data-anchor-id="combining-conditions">2.3. Combining Conditions</h2>
<p>Use logical operators <code>AND</code>, <code>OR</code>, <code>NOT</code> to chain multiple conditions.</p>
<pre class="postgresql"><code>SELECT *
FROM table
WHERE condition1
  AND condition2
  AND NOT condition3;</code></pre>
</section>
<section id="between" class="level2">
<h2 class="anchored" data-anchor-id="between">2.4. BETWEEN</h2>
<p>The <code>BETWEEN</code> operator can also be used as a condition, and is equivalent to a combination of &gt;= AND &lt;=. Note that both sides are inclusive.</p>
<p>For example, the following <code>BETWEEN</code> condition:</p>
<pre class="postgresql"><code>SELECT column1, column2
FROM table_name
WHERE column1 BETWEEN 0 AND 100;</code></pre>
<p>is equivalent to</p>
<pre class="postgresql"><code>SELECT column1, column2
FROM table_name
WHERE column1 &gt;= 0 AND column2 &lt;= 100;</code></pre>
</section>
<section id="in" class="level2">
<h2 class="anchored" data-anchor-id="in">2.5. IN</h2>
<p>The <code>IN</code> operator is another implicit combined condition. It saves us the hassle of writing out multiple <code>OR</code> conditions.</p>
<p>For example, the following <code>IN</code> condition:</p>
<pre class="postgresql"><code>SELECT column1, column2
FROM table_name
WHERE column1 (1, 2);</code></pre>
<p>is equivalent to</p>
<pre class="postgresql"><code>SELECT column1, column2
FROM table_name
WHERE column1 = 1 OR column1 = 2;</code></pre>
</section>
<section id="like" class="level2">
<h2 class="anchored" data-anchor-id="like">2.6. LIKE</h2>
<p>The <code>LIKE</code> operator is another implicit condition. Similarly to <code>IN</code>, it save us the hassle of writing out multiple <code>OR</code> conditions.</p>
<p>It allows us to match patterns using the wildcards <code>_</code> (to represent a single character) or <code>%</code> (to represent arbitrary number of characters).</p>
<p>The <code>LIKE</code> command is <strong>case-sensitive</strong>. The <code>ILIKE</code> command is a <strong>case-insensitive</strong> variant (<strong>I</strong>nsensitive <strong>LIKE</strong>)</p>
<pre class="postgresql"><code>SELECT product_id,
       manufacturer,
       drug
FROM pharmacy_sales
WHERE drug LIKE '%Relief%';</code></pre>
<p>We can use multiple underscores to match a specific number of unknown characters. For example, this will match “a” followed by any 3 characters.</p>
<pre class="postgresql"><code>WHERE word LIKE 'a___'</code></pre>
<p>The wildcards can be at multiple points in the pattern, e.g.</p>
<pre class="postgresql"><code>WHERE word LIKE 'f_c_'</code></pre>
</section>
<section id="order-by" class="level2">
<h2 class="anchored" data-anchor-id="order-by">2.7. ORDER BY</h2>
<p>The order of rows saved in the database is not guaranteed. Executing the same SELECT twice in a row can give a different ordering.</p>
<p>If we want a specific order, we can specify the <code>ORDER BY</code> column(s).</p>
<pre class="postgresql"><code>SELECT column1, column2
FROM table_name
ORDER BY column1;</code></pre>
<p>By default, this is in ascending order (<code>ASC</code>). We can pass <code>DESC</code> to instead return items in descending order. This can be column-specific.</p>
<pre class="postgresql"><code>SELECT column1, column2
FROM table_name
ORDER BY column1 ASC, column2 DESC;</code></pre>
<p>We can also pass the column numbers rather than names.</p>
<pre class="postgresql"><code>SELECT policy_holder_id, call_category, call_received
FROM callers
ORDER BY 1,3 DESC;</code></pre>
<p>We can use <code>ORDER BY</code> in conjunction with <code>LIMIT</code> where we need the top N highest/lowest results. We can also use <code>OFFSET</code> to skip a number of results.</p>
<p>For example, we can skip the first 10 rows and then return the next 5, so the following query returns the 11th-15th ordered results.</p>
<pre class="postgresql"><code>SELECT *
FROM callers
ORDER BY call_received DESC
OFFSET 10
LIMIT 5;</code></pre>
</section>
</section>
<section id="intermediate-sql-commands" class="level1">
<h1>3. Intermediate SQL Commands</h1>
<section id="aggregate-functions" class="level2">
<h2 class="anchored" data-anchor-id="aggregate-functions">3.1. Aggregate Functions</h2>
<p>We can aggregate data with <code>SUM</code>, <code>MIN</code>, <code>MAX</code>, <code>AVG</code>, <code>COUNT</code>.</p>
<pre class="postgresql"><code>SELECT COUNT(*)
FROM table_name;</code></pre>
</section>
<section id="group-by" class="level2">
<h2 class="anchored" data-anchor-id="group-by">3.2. GROUP BY</h2>
<p>The aggregate functions can be run on the entire table as above. But they come into their own when grouping by particular fields.</p>
<p>We can <code>GROUP BY</code> one or more columns.</p>
<pre class="postgresql"><code>SELECT
category,
    SUM(spend) AS total_spend
FROM product_spend
GROUP BY category;</code></pre>
</section>
<section id="having" class="level2">
<h2 class="anchored" data-anchor-id="having">3.3. HAVING</h2>
<p>Suppose we want to filter the data on the aggregated value. For example, in the previous example, we want to only return categories with <code>total_spend &gt; 10</code>.</p>
<p>Naively, we might try to use <code>WHERE</code>. But <code>WHERE</code> filters individual rows. Trying this will give some variation of the following error message</p>
<blockquote class="blockquote">
<p>aggregate functions are not allowed in WHERE</p>
</blockquote>
<p>The <code>HAVING</code> clause is essentially the analog of <code>WHERE</code>, but operates on grouped data rather than individual rows.</p>
<pre class="postgresql"><code>SELECT ticker, AVG(open)
FROM stock_prices
GROUP BY ticker
HAVING AVG(open) &gt; 200;</code></pre>
</section>
<section id="distinct" class="level2">
<h2 class="anchored" data-anchor-id="distinct">3.4. DISTINCT</h2>
<p>The <code>DISTINCT</code> keyword can specify that only rows where the column(s) are distinct. If we pass multiple columns, we will get all of the distinct pairs (or tuples in the general case) of those columns.</p>
<pre class="postgresql"><code>SELECT DISTINCT col1, col2
FROM table_name;</code></pre>
<p><code>DISTINCT</code> can be combined with aggregate functions, typically <code>COUNT</code>.</p>
<pre class="postgresql"><code>SELECT COUNT(DISTINCT user_id)
FROM trades;</code></pre>
</section>
<section id="arithmetic" class="level2">
<h2 class="anchored" data-anchor-id="arithmetic">3.5. Arithmetic</h2>
<p>We can use standard mathematical operations <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>^</code>, <code>%</code></p>
<pre class="postgresql"><code>SELECT salary + bonus AS total_compensation
FROM employees;</code></pre>
<p>We have the modulus operator <code>%</code> which returns the remainder of a division. This is often helpful in problems where we need to find odd or even values.</p>
<pre class="postgresql"><code>SELECT *
FROM measurements
WHERE measurement_num % 2 = 1</code></pre>
<p>These operations follow the usual BODMAS rule (or PEMDAS if you’re an asshole).</p>
</section>
<section id="mathematical-functions" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-functions">3.6. Mathematical Functions</h2>
<p>The following built-in maths functions are useful:</p>
<ul>
<li><code>ABS()</code> - absolute value</li>
<li><code>CEIL()</code> - round up</li>
<li><code>FLOOR()</code> - round down</li>
<li><code>ROUND(column_name, N)</code> - round to N decimal places</li>
<li><code>POWER(column_name, exponent)</code> - equivalent to <code>column_name ^ exponent</code></li>
<li><code>MOD(column_name, divisor) - equivalent to</code>column_name % divisor`</li>
</ul>
</section>
<section id="division" class="level2">
<h2 class="anchored" data-anchor-id="division">3.7. Division</h2>
<p>Division is SQL can be deceptively tricky. Naively, we might think we just do <code>col1 / col2</code>, job done.</p>
<p>But in practice, we can get weird results depending on the data types of the numerator or denominator.</p>
<table class="table">
<thead>
<tr class="header">
<th>Input</th>
<th>SQL Output</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>SELECT 10/4</code></td>
<td>2</td>
<td>2.5</td>
</tr>
<tr class="even">
<td><code>SELECT 10/2</code></td>
<td>5</td>
<td>5</td>
</tr>
<tr class="odd">
<td><code>SELECT 10/6</code></td>
<td>1</td>
<td>1.6666666667</td>
</tr>
<tr class="even">
<td><code>SELECT 10.0/4</code></td>
<td>2.5000000000000000</td>
<td>2.5</td>
</tr>
<tr class="odd">
<td><code>SELECT 10/3.0</code></td>
<td>3.3333333333333333</td>
<td>3.333333333</td>
</tr>
</tbody>
</table>
<p>We can coerce values to floats by:</p>
<ul>
<li>Using the <code>CAST(column_name AS FLOAT)</code> function</li>
<li>Multiplying <code>* 1.0</code></li>
<li>Explicitly using types with <code>::</code></li>
</ul>
<pre class="postgresql"><code>SELECT 
  CAST(10 AS DECIMAL)/4,
  CAST(10 AS FLOAT)/4,
  10 * 1.0 / 4
  10::DECIMAL / 4</code></pre>
</section>
<section id="nulls" class="level2">
<h2 class="anchored" data-anchor-id="nulls">3.8. Nulls</h2>
<p>A <code>NULL</code> value indicates the <strong>absence of a value</strong>. Missing data is different to data which is populated but empty, like a 0 or an empty string.</p>
<p>We can identify null and non-null values with <code>IS NULL</code> and <code>IS NOT NULL</code>.</p>
<pre class="postgresql"><code>SELECT *
FROM goodreads
WHERE book_title IS NULL;</code></pre>
<p>The <code>COALESCE</code> keyword allows us to pass multiple inputs and return the first non-null value. We can pass multiple columns, or a mix of columns and a hard-coded default value. This makes it useful to fill nulls. Think of it like the pandas <code>fillna</code> method.</p>
<pre><code>SELECT COALESCE(book_rating, 0)  -- fill NULL values with 0
FROM goodreads;</code></pre>
<p>We can also use the <code>IFNULL</code> keyword to fill null values.</p>
<pre class="postgresql"><code>SELECT 
  book_title, 
  IFNULL(book_rating, 0) AS rated_books  - fill NULL values with 0
FROM goodreads;</code></pre>
<p>In the above examples, <code>IFNULL</code> and <code>COALESCE</code> are interchangeable. In general, use <code>COALESCE</code> when checking multiple columns, e.g.&nbsp;<code>COALESCE(col1, col2, col3)</code>. If only checking one column, <code>IFNULL</code> is more concise.</p>
<p>The above examples are to <strong>replace null with values</strong>. We can do the opposite – <strong>conditionally replace values with nulls</strong> – using the <code>NULLIF</code> command. <code>NULLIF(expr1, expr2)</code> will return NULL if the two expressions are equal.</p>
</section>
<section id="case" class="level2">
<h2 class="anchored" data-anchor-id="case">3.9. CASE</h2>
<p>The <code>CASE</code> statement is used to create new columns, categorize data, or perform calculations based on specified conditions.</p>
<pre class="postgresql"><code>SELECT
  column_1,
  column_2, 
  CASE 
    WHEN condition_1 THEN result_1
    WHEN condition_2 THEN result_2
    ELSE result_3 -- If condition_1 and condition_2 are not met, return result_3 in ELSE clause
  END AS column_3_name -- Give your new column an alias
FROM table_1;  </code></pre>
<p>We can also use <code>CASE</code> inside a <code>WHERE</code> clause to filter rows based on specific conditions.</p>
<pre class="postgresql"><code>SELECT
  column_1,
  column_2
FROM table_1
WHERE CASE 
    WHEN condition_1 THEN result_1
    WHEN condition_2 THEN result_2
    ELSE result_3 -- If condition_1 and condition_2 are not met, return result_3 in ELSE clause
  END; </code></pre>
<p>As a concrete example of filtering, we may want to filter based on number of followers, where the threshold for followers depends on the platform</p>
<pre class="postgresql"><code>SELECT 
  actor, 
  character, 
  platform
FROM marvel_avengers
WHERE 
  CASE 
    WHEN platform = 'Instagram' THEN followers &gt;= 500000
    WHEN platform = 'Twitter' THEN followers &gt;= 200000
    ELSE followers &gt;= 100000
  END;</code></pre>
<p>We can also use aggregate functions like <code>COUNT</code>, <code>AVG</code>, <code>SUM</code> around a <code>CASE</code> statement to only include rows which meet a certain criteria.</p>
<pre class="postgresql"><code>SELECT
  platform,
  SUM(CASE 
    WHEN engagement_rate &gt;= 8.0 THEN followers
    ELSE 0
  END) AS high_engagement_followers_sum,
  SUM(CASE 
    WHEN engagement_rate &lt; 8.0 THEN followers
    ELSE 0
  END) AS low_engagement_followers_sum
FROM marvel_avengers
GROUP BY platform;</code></pre>
</section>
<section id="join" class="level2">
<h2 class="anchored" data-anchor-id="join">3.10. JOIN</h2>
<p>Joining multiple tables is the bread and butter of relational databases. We specify the tables to <code>JOIN</code> and the keys to join <code>ON</code>. We optionally define the <em>type</em> of join; this defaults to <code>INNER</code> if not specified.</p>
<pre class="postgresql"><code>SELECT *
FROM artists
JOIN songs
  ON artists.artist_id = songs.artist_id;</code></pre>
<p>There are 4 types of join:</p>
<ul>
<li><code>INNER JOIN</code> - Returns only the rows with matching values from <strong>both</strong> tables.</li>
<li><code>LEFT JOIN</code> - Returns all the rows from the left table and the matching rows from the right table. NULL values where there is no match in the right table.</li>
<li><code>RIGHT JOIN</code> - Returns all the rows from the right table and the matching rows from the left table. NULL values where there is no match in the left table.</li>
<li><code>FULL OUTER JOIN</code> - Returns all rows from <strong>either</strong> table. Where there is no match in either left or right, return a NULL value.</li>
</ul>
<p>We can perform <strong>conditional joins</strong> where we filter the tables as we join them. This avoids the need to join two, potentially large tables, then filter the very large result after joining.</p>
<p>This example will filter the orders table before joining it.</p>
<pre class="postgresql"><code>SELECT 
  g.book_title, 
  o.quantity
FROM goodreads AS g
INNER JOIN orders AS o 
  ON g.book_id = o.book_id
    AND o.quantity &gt; 2;</code></pre>
<p>Similarly, we can also use <code>CASE</code> statements in the <code>JOIN</code> to apply the CASE on the source table before joining, rather than on the potentially larger result set. This may be particularly helpful when we also want to <strong>filter</strong> on that <code>CASE</code> statement before joining.</p>
</section>
<section id="datetimes" class="level2">
<h2 class="anchored" data-anchor-id="datetimes">3.11. Datetimes</h2>
<p>Dates and timestamps are handled as specific data types in SQL.</p>
<p>The following functions are useful for getting the current date, time or datetime: - <code>CURRENT_DATE</code> - <code>CURRENT_TIME</code> - <code>CURRENT_TIMESTAMP</code> or <code>NOW()</code></p>
<p>We can use <strong>comparison operators</strong> <code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code> to compare datetimes. Aggregate functions like <code>MIN</code> and <code>MAX</code> also work.</p>
<pre class="postgresql"><code>SELECT *
FROM messages
WHERE sent_date &gt;= '2022-08-10 00:00:00';</code></pre>
<p>We can <strong>extract parts</strong> of the date with either <code>EXTRACT</code> or <code>DATE_PART</code>. These are equivalent, and can be used to extract year, month, day, hour, minute.</p>
<pre class="postgresql"><code>SELECT 
  EXTRACT(YEAR FROM sent_date) AS extracted_year,
  DATE_PART('year', sent_date) AS part_year
FROM messages;</code></pre>
<p>We can <strong>truncate</strong> a datetime to a specified granularity with <code>DATE_TRUNC</code>.</p>
<pre class="postgresql"><code>SELECT 
  DATE_TRUNC('day', sent_date) AS truncated_to_day
FROM messages;</code></pre>
<p>We can <strong>add and subtract</strong> datetimes using <code>INTERVAL</code>.</p>
<pre class="postgresql"><code>SELECT 
  sent_date + INTERVAL '2 days' AS add_2days,
  sent_date - INTERVAL '10 minutes' AS minus_10mins
FROM messages;</code></pre>
<p>Timestamps can be <strong>converted to strings</strong> with a specified format using <code>TO_CHAR</code>.</p>
<pre class="postgresql"><code>SELECT 
  TO_CHAR(sent_date, 'YYYY-MM-DD HH:MI:SS') AS formatted_iso8601
FROM messages;</code></pre>
<p>There are different formatting options for the string.</p>
<table class="table">
<colgroup>
<col style="width: 40%">
<col style="width: 29%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Format Name</th>
<th>Format</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ISO 8601 Date and Time</td>
<td>‘YYYY-MM-DD HH24:MI:SS’</td>
<td>‘2023-08-27 14:30:00’</td>
</tr>
<tr class="even">
<td>Date and Time with 12-hour Format</td>
<td>‘YYYY-MM-DD HH:MI:SS AM’</td>
<td>‘2023-08-27 02:30:00 PM’</td>
</tr>
<tr class="odd">
<td>Long Month Name, Day and Year</td>
<td>‘Month DDth, YYYY’</td>
<td>‘August 27th, 2023’</td>
</tr>
<tr class="even">
<td>Short Month Name, Day and Year</td>
<td>‘Mon DD, YYYY’</td>
<td>‘Aug 27, 2023’</td>
</tr>
<tr class="odd">
<td>Day, Month, and Year</td>
<td>‘DD Month YYYY’</td>
<td>‘27 August 2023’</td>
</tr>
<tr class="even">
<td>Day of the Month</td>
<td>‘Month’</td>
<td>‘August’</td>
</tr>
<tr class="odd">
<td>Day of the Week</td>
<td>‘Day’</td>
<td>‘Saturday’</td>
</tr>
</tbody>
</table>
<p>Strings can be converted to timestamps by casting. There are two equivalent syntaxes. For dates we can use <code>::DATE</code> or <code>TO_DATE()</code>. For timestamps we can use <code>::TIMESTAMP</code> or <code>TO_TIMESTAMP()</code>.</p>
<pre class="postgresql"><code>SELECT 
  sent_date::DATE AS casted_date,
  TO_DATE('2023-08-27', 'YYYY-MM-DD') AS converted_to_date,
  sent_date::TIMESTAMP AS casted_timestamp,
  TO_TIMESTAMP('2023-08-27 10:30:00', 'YYYY-MM-DD HH:MI:SS') AS converted_to_timestamp
FROM messages;</code></pre>
</section>
</section>
<section id="advanced-sql" class="level1">
<h1>4. Advanced SQL</h1>
<section id="cte-vs-subquery" class="level2">
<h2 class="anchored" data-anchor-id="cte-vs-subquery">4.1. CTE vs Subquery</h2>
<p>A <strong>Common Table Expression (CTE)</strong> is like a query within a query using a <code>WITH</code> statement.</p>
<p>A <strong>Subquery</strong> is a query within a query using parentheses.</p>
<section id="cte" class="level3">
<h3 class="anchored" data-anchor-id="cte">4.1.1. CTE</h3>
<p>We declare CTEs at the beginning of the query, which can help break down more complex queries to improve <strong>readability</strong>.</p>
<pre class="postgresql"><code>-- Start of a CTE
WITH genre_revenue_cte AS (
  SELECT
    genre,
    SUM(concert_revenue) AS total_revenue
  FROM concerts
  GROUP BY genre
)
-- End of a CTE

SELECT
  g.genre,
  g.total_revenue,
  AVG(c.concert_revenue) AS avg_concert_revenue
FROM genre_revenue_cte AS g
INNER JOIN concerts AS c 
  ON g.genre = c.genre
WHERE c.concert_revenue &gt; g.total_revenue * 0.5
GROUP BY g.genre, g.total_revenue;</code></pre>
<p>We can <strong>reuse</strong> the same CTE result multiple times, which can avoid redundant calculations.</p>
<p>They also allow for <strong>recursive queries</strong>.</p>
<pre class="postgresql"><code>WITH recursive_cte AS (
  SELECT 
    employee_id, 
    name, 
    manager_id
  FROM employees
  WHERE manager_id = @manager_id
  
  UNION ALL
  
  SELECT 
    e.employee_id, 
    e.name, 
    e.manager_id
  FROM employees AS e
  INNER JOIN recursive_cte AS r -- The RECURSIVE CTE is utilized here within the main CTE.
    ON e.ManagerID = r.employee_id
)

SELECT * 
FROM recursive_cte;</code></pre>
</section>
<section id="subquery" class="level3">
<h3 class="anchored" data-anchor-id="subquery">4.1.2. Subquery</h3>
<p>Subqueries are generally favoured where we need the result from some other small query. Think of it like lambda functions compared to defining a function in python; if the inner query is small then a subquery is more readable.</p>
<pre class="postgresql"><code>SELECT artist_name
FROM concerts
WHERE concert_revenue &gt; (
  SELECT AVG(concert_revenue) FROM concerts);</code></pre>
<p>In a similar vein, we can use subqueries to create and aggregate columns on the fly without sacrificing readability.</p>
<pre class="postgresql"><code>SELECT 
  artist_name, 
  genre, 
  concert_revenue,
  (SELECT AVG(concert_revenue) FROM concerts) AS avg_concert_revenue,
  (SELECT MAX(concert_revenue) FROM concerts) AS max_concert_revenue
FROM concerts;</code></pre>
<p>They can be useful for filtering on conditions in another query.</p>
<pre class="postgresql"><code>SELECT artist_name
FROM concerts
WHERE artist_id IN (
  SELECT artist_id FROM concert_revenue WHERE concert_revenue &gt; 500000);</code></pre>
<p><strong>Correlated subqueries</strong> are when we want to query one table based on a dynamic result in another (or itself). For example, return fields for the highest-grossing concerts of each genre.</p>
<pre class="postgresql"><code>SELECT 
  artist_name, 
  genre, 
  concert_revenue
FROM concerts AS c1
WHERE concert_revenue = (
  SELECT MAX(concert_revenue)
  FROM concerts AS c2
  WHERE c1.genre = c2.genre
);</code></pre>
</section>
</section>
<section id="window" class="level2">
<h2 class="anchored" data-anchor-id="window">4.2. WINDOW</h2>
<p>We have already calculated aggregates over <em>the whole table or certain groups</em>.</p>
<p><strong>Window</strong> functions allow us to create our own partitions, or “virtual windows”, and perform <strong>cumulative aggregates</strong> over these.</p>
<p>For example, if we want a cumulative total of revenue for each product type:</p>
<pre class="postgresql"><code>SELECT
  spend,
   SUM(spend) OVER (
     PARTITION BY product
     ORDER BY transaction_date) AS running_total
  FROM product_spend;</code></pre>
<p>The <code>PARTITION BY</code> clause defines our virtual windows. We can partition by multiple fields. <code>ORDER BY</code> determines the ordering for a running total. <code>SUM(spend) OVER</code> defines what aggreagtion we perform per partition. The <code>OVER</code> keyword is required for window function.</p>
<p>Common aggregates are <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MIN</code>, <code>MAX</code>, <code>FIRST_VALUE</code>, <code>LAST_VALUE</code>.</p>
<p>The distinction between <code>PARTITION BY</code> vs <code>GROUP BY</code> can feel subtle. Think of it like <code>.rolling()</code> vs <code>.groupby()</code> in pandas.</p>
<ul>
<li><code>GROUP BY</code> normally <strong>reduces the number of rows returned</strong> by grouping them up and calculating averages or sums for each group.</li>
<li><code>PARTITION BY</code> <strong>does not affect the number of rows returned</strong>, but it changes how a window function’s result is calculated.</li>
</ul>
</section>
<section id="ranking" class="level2">
<h2 class="anchored" data-anchor-id="ranking">4.3. Ranking</h2>
<p>There are several ranking functions – <code>RANK</code>, <code>DENSE_RANK</code>, <code>ROW_NUMBER</code> – we can use to <strong>ranks rows based on specific criteria</strong>. This assigns numbers indicating the position of the data within a certain “window”.</p>
<p>The syntax for all of them follows the same pattern:</p>
<pre class="postgresql"><code>SELECT 
  RANK() / DENSE_RANK() / ROW_NUMBER() OVER ( -- Compulsory expression
    PARTITION BY partitioning_expression -- Optional expression
    ORDER BY order_expression) -- Compulsory expression
FROM table_name;</code></pre>
<p>The differences between the ranking functions:</p>
<ul>
<li><code>ROW_NUMBER()</code>: Essentially numbers the rows in order.</li>
<li><code>RANK()</code>: Tied values are given the <em>same rank</em>, <strong>skipping</strong> subsequent ranks which leaves gaps in the sequence.</li>
<li><code>DENSE_RANK()</code>: Tied values are given the <em>same rank</em>, <strong>without skipping</strong> subsequent ranks so there are no gaps in the sequence.</li>
</ul>
</section>
<section id="leadlag" class="level2">
<h2 class="anchored" data-anchor-id="leadlag">4.4. Lead/Lag</h2>
<p>The time series window functions <code>LAG</code> and <code>LEAD</code> allow us to access data from rows before or after the current row.</p>
<pre class="postgresql"><code>LEAD(column_name, offset) OVER (  -- Compulsory expression
  PARTITION BY partition_column -- Optional expression
  ORDER BY order_column) -- Compulsory expression</code></pre>
<p>This can “feel” similar to the <code>OFFSET</code> function. The difference is <code>OFFSET</code> skips rows in the output, resulting in a different result set. <code>LAG</code> <em>accesses previous rows within the same result set</em>, allowing for row-wise comparisons <em>within a window</em>. <code>OFFSET</code> wouldn’t work in a window function.</p>
</section>
<section id="self-joins" class="level2">
<h2 class="anchored" data-anchor-id="self-joins">4.5. Self Joins</h2>
<p>We can join a table to itself to match on the data within the table.</p>
<p>As an example, the query below will take each book in the table and give suggestions of other books in the same genre.</p>
<pre class="postgresql"><code>SELECT
  b1.genre,
  b1.book_title AS current_book,
  b2.book_title AS suggested_book
FROM goodreads AS b1
INNER JOIN goodreads AS b2
  ON b1.genre = b2.genre
WHERE b1.book_id != b2.book_id  -- Don't suggest the same book
ORDER BY b1.book_title;</code></pre>
</section>
<section id="set-operations---union-intersect-except" class="level2">
<h2 class="anchored" data-anchor-id="set-operations---union-intersect-except">4.6. Set operations - UNION, INTERSECT, EXCEPT</h2>
<p>The set operation <code>UNION</code> allows us to combine data <strong>vertically</strong>, i.e. appending <strong>columns</strong>.</p>
<p>In the same way that <code>JOIN</code>s allow us to combine data <strong>horizontally</strong>, i.e.&nbsp;appending <strong>rows</strong>.</p>
<p>For all set operations – <code>UNION</code>, <code>INTERSECT</code>, <code>EXCEPT</code> – the number of columns, data types, and order of columns must match between the two <code>SELECT</code> statements.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="image.png" class="img-fluid figure-img"></p>
<figcaption>JOIN vs UNION. From datalemur.com</figcaption>
</figure>
</div>
<p>The <code>UNION</code> keyword gives all <strong>unique</strong> rows, <code>UNION ALL</code> <strong>retains duplicate</strong> rows.</p>
<pre class="postgresql"><code>SELECT col1, col2
FROM table1
UNION ALL
SELECT col1, col2
FROM table2;</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="image-1.png" class="img-fluid figure-img"></p>
<figcaption>UNION vs UNION ALL. From datalemur.com</figcaption>
</figure>
</div>
<p>The <code>INTERSECT</code> command gives the intersection between two sets, i.e.&nbsp;the common rows present in both.</p>
<pre class="postgresql"><code>SELECT order_id
FROM orders
WHERE quantity &gt;= 2
INTERSECT
SELECT order_id
FROM deliveries
WHERE delivery_status = 'Delivered';</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="image-2.png" class="img-fluid figure-img"></p>
<figcaption>INTERSECT. From datalemur.com</figcaption>
</figure>
</div>
<p><code>EXCEPT</code> gives all the unique rows in A that are <strong>not</strong> present in B.</p>
<pre class="postgresql"><code>SELECT ingredient
FROM recipe_1
EXCEPT
SELECT ingredient
FROM recipe_2;</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="image-3.png" class="img-fluid figure-img"></p>
<figcaption>EXCEPT. From datalemur.com</figcaption>
</figure>
</div>
</section>
<section id="sql-code-best-practices" class="level2">
<h2 class="anchored" data-anchor-id="sql-code-best-practices">4.7. SQL Code Best Practices</h2>
<ul>
<li><code>UPPERCASE</code> for <strong>keywords</strong>:</li>
<li><code>lowercase</code> or <code>snake_case</code> for <strong>names</strong></li>
<li>Descriptive and concise <strong>aliases</strong></li>
<li>Consistent formatting and <strong>indentation</strong></li>
<li>Avoid SELECT *, explicitly specify columns</li>
<li>Use <code>JOIN</code>s explicitly for clarity
<ul>
<li>Rather than relying on <code>FROM table1, table2</code> syntax</li>
<li>Specify the <strong>type</strong> of join (INNER, LEFT, RIGHT, OUTER)</li>
</ul></li>
<li>Format <strong>dates</strong> consistently - YYYY-MM-DD</li>
<li><strong>Comment</strong> wisely
<ul>
<li>Use <code>--</code> for inline comments and <code>/* ... */</code> for multiline</li>
</ul></li>
</ul>
</section>
<section id="execution-order" class="level2">
<h2 class="anchored" data-anchor-id="execution-order">4.8. Execution Order</h2>
<p>The query engine for the database handles the <a href="https://www.datacamp.com/tutorial/sql-order-of-execution">order of execution</a> of commands in the query. This is helpful to understand what happens in the database under the hood so we can optimise our queries better.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 3%">
<col style="width: 86%">
</colgroup>
<thead>
<tr class="header">
<th>Clause</th>
<th>Order</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FROM / JOIN</td>
<td>1</td>
<td>The query begins with the FROM clause, where the database identifies the tables involved and accesses the necessary data.</td>
</tr>
<tr class="even">
<td>WHERE</td>
<td>2</td>
<td>The database applies the conditions specified in the WHERE clause to filter the data retrieved from the tables in the FROM clause.</td>
</tr>
<tr class="odd">
<td>GROUP BY</td>
<td>3</td>
<td>If a GROUP BY clause is present, the data is grouped based on the specified columns, and aggregation functions (such as SUM(), AVG(), COUNT()) are applied to each group.</td>
</tr>
<tr class="even">
<td>HAVING</td>
<td>4</td>
<td>The HAVING clause filters the aggregated data based on specified conditions.</td>
</tr>
<tr class="odd">
<td>SELECT / DISTINCT</td>
<td>5</td>
<td>The SELECT clause defines the columns to be included in the final result set.</td>
</tr>
<tr class="even">
<td>ORDER BY</td>
<td>6</td>
<td>If an ORDER BY clause is used, the result set is sorted according to the specified columns.</td>
</tr>
<tr class="odd">
<td>LIMIT / OFFSET</td>
<td>7</td>
<td>If LIMIT or OFFSET clause is present, the result set is restricted to the specified number of rows and optionally offset by a certain number of rows.</td>
</tr>
</tbody>
</table>
</section>
<section id="string-functions" class="level2">
<h2 class="anchored" data-anchor-id="string-functions">4.9. String Functions</h2>
<p>String functions are useful for cleaning and manipulating text data.</p>
<p>We can change case with <code>UPPER</code> and <code>LOWER</code>.</p>
<pre class="postgresql"><code>SELECT 
  UPPER(text_col) AS upper_case_text,
  LOWER(text_col) AS lower_case_text
FROM table_name;</code></pre>
<p>We can extract the first or last N characters of a string with <code>LEFT(col, N)</code> and <code>RIGHT(col, N)</code>. If N is greater than the length of the string, it will return the whole string.</p>
<pre class="postgresql"><code>SELECT 
  LEFT(text_col, 5) AS left_substring,
  RIGHT(text_col, 5) AS right_substring
FROM table_name;</code></pre>
<p>We can calculate the <code>LENGTH</code> of a string.</p>
<pre class="postgresql"><code>SELECT 
  LENGTH(text_col) AS text_length
FROM table_name;</code></pre>
<p>We can find the index of a substring within a larger string using <code>POSITION(substring IN string)</code>. This returns 0 if the substring is not found.</p>
<pre class="postgresql"><code>SELECT POSITION('substring' IN text_col) AS position_result
FROM table_name;</code></pre>
<p>White spaces (and other characters) can be trimmed from the left, right or both sides using <code>LTRIM</code>, <code>RTRIM</code>, <code>BTRIM</code>. They can each take an optional second argument specifying the character to trim. The <code>TRIM</code> command removes spaces from both sides of the string; essentially a shorthand for <code>BTRIM(text_col, ' ')</code>.</p>
<pre class="postgresql"><code>SELECT 
  TRIM('     Spiderman') AS full_trim,
  LTRIM('Iron Man', 'Iron ') AS left_trim,
  RTRIM('Scarlet Witch', ' Witch') AS right_trim,
  BTRIM('   Falcon   ', ' ') AS combination_trim1,
  BTRIM('...Iron Man...', '.') AS combination_trim2
FROM marvel_avengers;</code></pre>
<p>We can combine multiple string fields with <code>CONCAT</code>.</p>
<pre class="postgresql"><code>SELECT 
    CONCAT(col1, col2)
FROM table_name;</code></pre>
<p>We can also “concatenate with separator” using <code>CONCAT_WS</code>. So these two queries would be equivalent.</p>
<pre class="postgresql"><code>SELECT 
    CONCAT(col1, '-', col2),
    CONCAT_WS('-', col1,col2)
FROM table_name;</code></pre>
<p>We can extract a <code>SUBSTRING</code> from a larger string using the following syntax: <code>SUBSTRING(string, start_position, length [optional])</code>. The <code>start_position</code> argument can be a negative index, meaning it counts from the end of the string. The <code>length</code> argument is optional. If not provided it will return the rest of the string.</p>
<pre class="postgresql"><code>SELECT 
    SUBSTRING(col1, 2),  -- From second chracter onwards
    SUBSTRING(col1, 2, 5)  -- 5 characters, starting from the 2nd
FROM table_name;</code></pre>
<p>We can split text into segments based on a specific delimiter using <code>SPLIT_PART(string, delimiter, part_number)</code>.</p>
<pre class="postgresql"><code>SELECT 
  SPLIT_PART('Spider-Man', '-', 1) AS split_part_1, -- Extracting the first part: 'Spider'
  SPLIT_PART('Spider-Man', '-', 2) AS split_part_2, -- Extracting the second part: 'Man'
  SPLIT_PART('Black Widow', ' ', -1) AS split_part_3 -- Extracting the last part: 'Widow'
FROM marvel_avengers;</code></pre>
</section>
</section>
<section id="creating-and-modifying-data" class="level1">
<h1>5. Creating and Modifying Data</h1>
<p>We can use the <code>CREATE</code> command to create new <code>DATABASE</code> or <code>TABLE</code> objects.</p>
<p><code>ALTER</code> allows us to modify an existing table.</p>
<p>We can add data to a table using <code>INSERT</code>.</p>
<pre class="postgresql"><code>INSERT INTO Customer (id, first_name, last_name)
VALUES (15, ‘John’, ‘Cena)</code></pre>
<p>If the primary key already exists for a row, we will receive an error when trying to insert. We can use <code>UPDATE</code> to <strong>overwrite</strong> existing rows.</p>
<p>The <code>UPSERT</code> command is a combination of the two: INSERT the data if it does not already exist, otherwise UPDATE it.</p>
<p>We can use <code>DELETE</code> to remove rows from the table.</p>
<p>We can use <code>DROP</code> to delete an entire table or database. <strong>Use wisely!</strong></p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<ul>
<li><a href="https://datalemur.com/sql-tutorial">Data Lemur</a></li>
<li><a href="https://www.datacamp.com/tutorial/sql-order-of-execution">SQL Order of Execution</a></li>
<li><a href="https://stackoverflow.com/questions/2404565/what-is-the-difference-between-partition-by-and-group-by">PARTITION BY vs GROUP BY</a></li>
</ul>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>