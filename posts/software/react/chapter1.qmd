---
title: "Getting Started with React"
description: "React Complete Guide: Section 1"
date: "2024-03-04"
image: "react.png"
categories: [Engineering, Software, React, WebDev]
draft: true
---

# React

These notes are from the [Udemy course](https://www.udemy.com/share/101Wby3@bwKzzF5Lsdyap2056rQpfSQPMwoPeWakiLbWURQe1VXLfFumI76lGqitdKHEWO3C/) "React: The Complete Guide".

## 1. Getting Started
React is a Javascript library for building user interfaces. It is less cumbersome and error-prone than using vanilla JS.

[Code sandbox](https://codesandbox.io/) is an in-browser environment to experiment with UIs.
As an example, the same page is implemented in [pure Javascript](https://codesandbox.io/p/sandbox/vanilla-js-demo-6049kj) and [React](https://codesandbox.io/p/sandbox/react-vs-vanilla-demo-uc08fv). 
The latter is much easier to follow, modularise and requires less boilerplate.

- With React, you write *declarative* code: you define the goal, not the steps to get there.
- With vanilla JS, you write *imperative* code, defining the steps, not the goal.


A build tool (like Vite or Next.js) is necessary because the Javascript (specifically the JSX) must be transformed. React uses JSX which allows us to "mix" HTML and JS, so that we can define layout and functionality in the same place. This isn't natively supported by the browser, so a build tool transforms this to pure html and JS.


## 2. Javascript Refresher
Adding JS to a page in script tags. 
Either in the body of the script tag, or preferably as a separate js file that’s then called as the src parameter of the script tag. 
The defer parameter means the script won’t be called until the rest of the body is loaded. 
The type=module parameter means the JavaScript file will be treated as a module. 



## 3. React Introduction

Components are a core concept. They bundle html, CSS and JS into reusable blocks. 

In vanilla JS, the JavaScript and HTML are in different files, so it can be hard to follow what needs to be changed where. Related code lives together, which is a key benefit of React and component style coding. 

JSX is a JavaScript syntax extension that allows us to write HTML in JavaScript files. This is not natively supported by browsers, so requires transformation by the build system, such as Vite. 

The build process (of some but not all build tools) relies on the jsx file extension to indicate a JSX file that needs transformation. The browser does not care, as it never sees (and cannot read) these jsx files directly. Similarly, some build processes require the file extension in the imports but others don’t. 

Components must:
1. Start with an upper case letter - so they do not clash with built ins like header
2. Return a renderable object

React creates a component tree. Your components do not end up as source code directly. The build process traverses the tree until each component is resolved into built ins, and then these appear in the source code. 

Dynamic values. 
Use curly braces. 
Ideally declare as constants rather than having complicated inline expressions. 
Images should be exported then the dynamic value passed as the src of the image. This prevents the image being lost in the build process if the build ignores files with certain extensions. 

Dynamic values can be passed to components as props. React components take a single argument called props, which is an object of key:value pairs passed to the component. 
If you have an object of props to pass, you can use the spread operator to avoid writing them out individually. 
Also use object destructuring inside the component to pick out the variables. 

Project structure. 
It is good practice that each component is in its own file. File name should match the component name and be the default export. 
Also split out style CSS files and keep these alongside the component. CSS files need to be imported by each component file that uses it. 
The styles are NOT automatically scoped to the component that uses them. They will apply to all components with that name. For example, if you apply header styling to a custom Header component, it will also apply to the built in header html component. 

The children prop is passed by all components and it is the value between the component tags. It can be used for HTML tag-style syntax. 

We can react to events by passing a function to onClick or similar. In vanilla JS, we would need to select the element and add an event listener, but react is declarative. 
We can define the handleClick function inside the component so that it has access to the component’s props and state. 
We can pass functions as props. This is useful as we can pass state setter functions down to nested components. This should be a pointer to the function, not the executed function itself, e.g. handleClick NOT handleClick()

If we want to modify the args that we pass to the function in onClick, use an anonymous arrow function () => handleSelect(arg)
That doesn’t actually get executed until onClick is called. 

By default, React components only execute once, even if an internal variable changes. You have to “tell” React to execute something again. This is where state comes in useful. React checks if UI updates are needed by comparing old output with new and applying the difference. So we use states rather than regular variables to indicate that a re-render is required if the state changes. State is essentially a special registered variable that react handles differently. 
If the state of a component changes, that component and its children in the component tree re-render. 

Use state is a “hook”. Hooks must be declared in the top level of a component function, they can’t be nested in internal functions such as event handlers, and they also can’t be declared outside of functions. It returns an array of two elements, the state value and a setter. A default state value can be passed to use state. 
The setter “schedules” an update, but that isn’t necessarily immediate. So you can see unexpected things when logging a value after the setter in code, where the logged value is still the “old” state value because the UI update has been scheduled but not completed yet. 

Conditionally rendering content. 
Use JSX with a ternary expression 
{ selectedState ? ComponentA : ComponentB }

null is allowed in place of a component. 

The and operator can also be used for this. In JS, if the first term is truth then it returns the second term, which is what we want. 

{ selectedState && ComponentA }


A third option is to save the component as a variable. See lesson 55 7:21 for the syntax to add to notes. 

Conditional styling. 
We can set className as a JSX expression and use a ternary expression , eg to check if the button is selected and apply a different className depending on whether it’s selected. 

Outputting lists dynamically. 
JSX is capable of outputting lists of renderable components. We map over the array. 
MyArray.map((item) => (<Component/>))

Add a key prop to the Component which uniquely identifies the item to avoid warnings raised by React. 

Module summary. 
Useful for subsection headings. 

Building UI with components. 
Using and outputting data. 
Handling user events. 
Using state for interactive content. 


React essentials deep dive section. 

You don’t NEED JSX, but it makes life easier. Copy example from lesson 60 3:00 using React.create element to manipulate the DOM directly. It’s not as clear. But it avoids the need for a build process because it IS valid JavaScript supported by the browser. 

Using Fragment. 
A JavaScript function must return one value, it cannot return multiple values. This is true of React components, since they are really just syntactic sugar around JavaScript code. 

So if we have two or more sibling components being returned, we must wrap them in a parent component. Naively, we could just use a div, but this adds an unnecessary extra component to our tree. 

An alternative is to use Fragment. This can be imported from react and used as a parent component without actually creating any new component when built. In newer versions of react, we can skip the import and just use empty opening and closing tags to create a Fragment. 

Splitting components. 
Remember React will re-render a component and all its child components when a state changes. So if a state is too high up the component tree, it will cause unnecessary re-rendering of many other components. 
This is an indication that a component needs to be split out and its state managed lower down the tree. 
